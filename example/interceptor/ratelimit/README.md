# Rate limit interceptor
In this example, we will try to create GoFrame server rate limit interceptor enabled.

Rate limit interceptor contains bellow algorithm

| Type | Description |
| ---- | ---- |
| tokenBucket | [wiki](https://en.wikipedia.org/wiki/Token_bucket) |
| leakyBucket | [wiki](https://en.wikipedia.org/wiki/Leaky_bucket) |

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Quick start](#quick-start)
  - [Code](#code)
- [Options](#options)
  - [Context Usage](#context-usage)
- [Example](#example)
    - [Start server](#start-server)
    - [Output](#output)
    - [Code](#code-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Quick start
Get rk-gf package from the remote repository.

```go
go get -u github.com/rookie-ninja/rk-gf
```

### Code
Add rkgflimit.Interceptor() with option.

```go
import     "github.com/rookie-ninja/rk-gf/interceptor/ratelimit"
```
```go
    // ********************************************
    // ********** Enable interceptors *************
    // ********************************************
	interceptors := []ghttp.HandlerFunc{
        rkgflimit.Interceptor(),
    }
```

## Options
| Name | Default | Description |
| ---- | ---- | ---- |
| rkmidlimit.WithEntryNameAndType(entryName, entryType string) | entryName=gin, entryType=gin | entryName and entryType will be used to distinguish options if there are multiple interceptors in single process. |
| rkmidlimit.WithReqPerSec(int) | int | Global rate limit per second. |
| rkmidlimit.WithReqPerSecByPath(path string, reqPerSec int) | "", 0 | Request limiter by gin method. |
| rkmidlimit.WithAlgorithm(algo string) | tokenBucket | Algorithm of rate limiter. |
| rkmidlimit.WithGlobalLimiter(l Limiter) | nil | Provider user defined limiter. |
| rkmidlimit.WithLimiterByPath(path string, l Limiter) | "", nil | Provider user defined limiter by gin method. |

```go
	// ********************************************
	// ********** Enable interceptors *************
	// ********************************************
	interceptors := []ghttp.HandlerFunc{
		rkgflog.Interceptor(),
		rkgflimit.Interceptor(
		// Entry name and entry type will be used for distinguishing interceptors. Recommended.
		// rkmidlimit.WithEntryNameAndType("greeter", "gin"),
		//
		// Provide algorithm, rkmidlimit.LeakyBucket and rkmidlimit.TokenBucket was available, default is TokenBucket.
		//rkmidlimit.WithAlgorithm(rkmidlimit.LeakyBucket),
		//
		// Provide request per second, if provide value of zero, then no requests will be pass through and user will receive an error with
		// resource exhausted.
		//rkmidlimit.WithReqPerSec(10),
		//
		// Provide request per second with path name.
		// The name should be full path name. if provide value of zero,
		// then no requests will be pass through and user will receive an error with resource exhausted.
		//rkmidlimit.WithReqPerSecByPath("/rk/v1/greeter", 0),
		//
		// Provide user function of limiter
		//rkmidlimit.WithGlobalLimiter(func() error {
		//	 return nil
		//}),
		//
		// Provide user function of limiter by path name.
		// The name should be full path name.
		//rkmidlimit.WithLimiterByPath("/rk/v1/greeter", func() error {
		//	 return nil
		//}),
		),
	}
```

### Context Usage
| Name | Functionality |
| ------ | ------ |
| rkgfctx.GetLogger(*ghttp.Request) | Get logger generated by log interceptor. If there are X-Request-Id or X-Trace-Id as headers in incoming and outgoing metadata, then loggers will has requestId and traceId attached by default. |
| rkgfctx.GetEvent(*ghttp.Request) | Get event generated by log interceptor. Event would be printed as soon as RPC finished. |
| rkgfctx.GetIncomingHeaders(*ghttp.Request) | Get incoming header. |
| rkgfctx.AddHeaderToClient(ctx, "k", "v") | Add k/v to headers which would be sent to client. This is append operation. |
| rkgfctx.SetHeaderToClient(ctx, "k", "v") | Set k/v to headers which would be sent to client. |

## Example
In this example, we enable log interceptor either to monitor RPC status.

#### Start server
```shell script
$ go run greeter-server.go
```

#### Output
- Server side (event)
```shell script
$ curl "localhost:8080/rk/v1/greeter?name=rk-dev" 
{
    "error":{
        "code":429,
        "status":"Too Many Requests",
        "message":"",
        "details":[
            "slow down your request"
        ]
    }
}
```

```shell script
------------------------------------------------------------------------
endTime=2021-11-26T15:17:29.801501+08:00
startTime=2021-11-26T15:17:29.801252+08:00
elapsedNano=248712
timezone=CST
ids={"eventId":"dc42bc32-c788-4cdc-a25a-dde0ee10ede4"}
app={"appName":"rk","appVersion":"","entryName":"gf","entryType":"gf"}
env={"arch":"amd64","az":"*","domain":"*","hostname":"lark.local","localIP":"10.8.0.2","os":"darwin","realm":"*","region":"*"}
payloads={"apiMethod":"GET","apiPath":"/rk/v1/greeter","apiProtocol":"HTTP/1.1","apiQuery":"name=rk-dev","userAgent":"curl/7.64.1"}
error={"slow down your request":1}
counters={"rateLimitWaitMs":0}
pairs={}
timing={}
remoteAddr=localhost:57748
operation=/rk/v1/greeter
resCode=429
eventStatus=Ended
EOE
```

#### Code
- [greeter-server.go](greeter-server.go)
